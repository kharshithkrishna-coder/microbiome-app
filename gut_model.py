# -*- coding: utf-8 -*-
"""GUT MODEL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T8cOvuxdoopqT4QDd4U6Y80ZncfKmPHO
"""
# Add missing imports at the top:
from IPython.display import clear_output
import ipywidgets as widgets

# Replace the uploaded file load with direct file reading:
otu = pd.read_csv(
    "india_species_abundance_clean.tsv",
    sep="\t",
    index_col=0
)
import pandas as pd
import numpy as np
import networkx as nx
from scipy.stats import spearmanr
from IPython.display import clear_output
import ipywidgets as widgets
import matplotlib.pyplot as plt


# Load uploaded file
otu = pd.read_csv(
    "india_species_abundance_clean.tsv",
    sep="\t",
    index_col=0
)

otu.head()
# Mean abundance per species
baseline_abundance = otu.mean(axis=1)

baseline_abundance.sort_values(ascending=False).head(10)

"""Spearman and consensing edges"""

# Compute Spearman correlation matrix
corr, pval = spearmanr(otu.T)

corr_df = pd.DataFrame(
    corr,
    index=otu.index,
    columns=otu.index
)

pval_df = pd.DataFrame(
    pval,
    index=otu.index,
    columns=otu.index
)
def bootstrap_spearman(data, n_boot=100, alpha=0.05):
    species = data.index
    edge_counts = {}

    for _ in range(n_boot):
        boot = data.sample(frac=1, replace=True, axis=1)
        corr, pval = spearmanr(boot.T)

        corr = pd.DataFrame(corr, index=species, columns=species)
        pval = pd.DataFrame(pval, index=species, columns=species)

        for i in species:
            for j in species:
                if i != j and pval.loc[i, j] < alpha:
                    sign = np.sign(corr.loc[i, j])
                    edge_counts[(i, j)] = edge_counts.get((i, j), 0) + sign

    return edge_counts

edge_counts = bootstrap_spearman(otu)

"""SPIEC EASI"""

G = nx.DiGraph()

for (i, j), score in edge_counts.items():
    weight = score / 100  # normalize
    if abs(weight) > 0.1:  # consensus threshold
        G.add_edge(i, j, weight=weight)

print(f"Interaction network: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges")

"""Agora"""

traits = pd.DataFrame({
    "SCFA": [1, 0, 1, 0],
    "Siderophore": [0, 1, 0, 1],
    "Vitamin_Biosynthesis": [1, 0, 1, 0],
    "pH_reduction": [1, 0, 0, 0],
    "Barrier_support": [1, 0, 1, 0]
}, index=[
    "Lactobacillus_plantarum",
    "Escherichia_coli",
    "Bifidobacterium_longum",
    "Enterobacter_cloacae"
])

traits
nutrients = {
    "Iron": {"SCFA":0.4,"pH_reduction":0.3,"Barrier_support":0.2,"Siderophore":-0.6},
    "Vitamin_B12": {"Vitamin_Biosynthesis":0.7,"Barrier_support":0.2},
    "Folate": {"Vitamin_Biosynthesis":0.6},
    "Calcium": {"SCFA":0.5,"pH_reduction":0.4},
    "Magnesium": {"SCFA":0.4},
    "Zinc": {"Barrier_support":0.4,"Siderophore":-0.5}
}
def absorption_score(abundance, nutrient):
    score = 0
    for sp, ab in abundance.items():
        if sp in traits.index:
            for trait, w in nutrients[nutrient].items():
                score += ab * traits.loc[sp, trait] * w
    return score

"""MICROBE ADDITION"""

def simulate_addition(abundance, microbe, delta):
    new = abundance.copy()
    new[microbe] = new.get(microbe, 0) + delta

    if microbe in G:
        for tgt in G.successors(microbe):
            new[tgt] += delta * G[microbe][tgt]["weight"]

    new[new < 0] = 0
    return new
new_abundance = simulate_addition(
    baseline_abundance,
    "Lactobacillus_plantarum",
    delta=0.02
)

for n in nutrients:
    print(
        n,
        "before:", round(absorption_score(baseline_abundance, n),3),
        "after:", round(absorption_score(new_abundance, n),3)
    )

"""NUTRIENT TARGET"""

def recommend_microbes(nutrient, top=3):
    pos = {}
    neg = {}

    for sp in traits.index:
        score = sum(
            traits.loc[sp, t] * w
            for t, w in nutrients[nutrient].items()
        )

        if score > 0:
            pos[sp] = score
        elif score < 0:
            neg[sp] = score

    inc = sorted(pos.items(), key=lambda x: x[1], reverse=True)[:top]
    dec = sorted(neg.items(), key=lambda x: x[1])[:top]

    return inc, dec

inc, dec = recommend_microbes("Iron")

print("Increase:")
for sp, sc in inc:
    print(sp, sc)

print("\nDecrease:")
for sp, sc in dec:
    print(sp, sc)

"""FOR MORE SPECIES"""

# Extract genus from species names
species_list = baseline_abundance.index

def get_genus(species):
    return species.split("_")[0]

genus_map = {sp: get_genus(sp) for sp in species_list}

list(genus_map.items())[:10]
# Genus-level functional priors (confidence 0â€“1)
genus_traits = {
    "Lactobacillus": {
        "SCFA": 0.9,
        "pH_reduction": 0.9,
        "Barrier_support": 0.8,
        "Vitamin_Biosynthesis": 0.6,
        "Siderophore": 0.0
    },
    "Bifidobacterium": {
        "SCFA": 0.8,
        "pH_reduction": 0.7,
        "Barrier_support": 0.8,
        "Vitamin_Biosynthesis": 0.7,
        "Siderophore": 0.0
    },
    "Bacteroides": {
        "SCFA": 0.6,
        "pH_reduction": 0.3,
        "Barrier_support": 0.4,
        "Vitamin_Biosynthesis": 0.3,
        "Siderophore": 0.4
    },
    "Prevotella": {
        "SCFA": 0.7,
        "pH_reduction": 0.4,
        "Barrier_support": 0.4,
        "Vitamin_Biosynthesis": 0.3,
        "Siderophore": 0.3
    },
    "Escherichia": {
        "SCFA": 0.1,
        "pH_reduction": 0.0,
        "Barrier_support": 0.1,
        "Vitamin_Biosynthesis": 0.1,
        "Siderophore": 0.9
    },
    "Enterobacter": {
        "SCFA": 0.1,
        "pH_reduction": 0.0,
        "Barrier_support": 0.1,
        "Vitamin_Biosynthesis": 0.1,
        "Siderophore": 0.8
    }
}
# Auto-generate species-level trait table
all_traits = []

for sp, genus in genus_map.items():
    if genus in genus_traits:
        row = genus_traits[genus].copy()
    else:
        # Default weak functionality (unknown genus)
        row = {
            "SCFA": 0.2,
            "pH_reduction": 0.1,
            "Barrier_support": 0.1,
            "Vitamin_Biosynthesis": 0.1,
            "Siderophore": 0.2
        }
    row["Species"] = sp
    all_traits.append(row)

traits = pd.DataFrame(all_traits).set_index("Species")

traits.head()
for n in nutrients:
    print(
        n,
        "baseline:", round(absorption_score(baseline_abundance, n), 3)
    )

"""PREDICTION"""


# -----------------------------------
# Prepare dropdown options
# -----------------------------------

available_bacteria = sorted(
    list(set(baseline_abundance.index).intersection(traits.index))
)

available_nutrients = list(nutrients.keys())

# -----------------------------------
# Widgets
# -----------------------------------

bacteria_dropdown = widgets.Dropdown(
    options=available_bacteria,
    description="Bacteria:",
    style={"description_width": "initial"},
    layout=widgets.Layout(width="400px")
)

nutrient_dropdown = widgets.Dropdown(
    options=available_nutrients,
    description="Nutrient:",
    style={"description_width": "initial"},
    layout=widgets.Layout(width="300px")
)

delta_input = widgets.FloatText(
    value=0.02,
    description="Î” Abundance:",
    step=0.01,
    style={"description_width": "initial"},
    layout=widgets.Layout(width="300px")
)

run_button = widgets.Button(
    description="Run Simulation",
    button_style="success"
)

output_box = widgets.Output()

# -----------------------------------
# Simulation logic
# -----------------------------------

def run_simulation(button):
    with output_box:
        clear_output()

        microbe = bacteria_dropdown.value
        nutrient = nutrient_dropdown.value
        delta = delta_input.value

        before = absorption_score(baseline_abundance, nutrient)

        new_abundance = simulate_addition(
            baseline_abundance,
            microbe,
            delta
        )

        after = absorption_score(new_abundance, nutrient)

        print("ðŸ§¬ Simulation Result")
        print("-------------------")
        print(f"Bacteria added : {microbe}")
        print(f"Nutrient       : {nutrient}")
        print(f"Î” Abundance    : {delta}")
        print()
        print(f"Absorption BEFORE : {round(before, 4)}")
        print(f"Absorption AFTER  : {round(after, 4)}")
        print(f"Change (Î”)        : {round(after - before, 4)}")

run_button.on_click(run_simulation)

# -----------------------------------
# Display UI
# -----------------------------------

display(
    widgets.VBox([
        bacteria_dropdown,
        nutrient_dropdown,
        delta_input,
        run_button,
        output_box
    ])
)

"""DIET MAPPING"""

# Diet components mapped to bacterial growth propensity (0â€“1)
nutrients = {
    "Iron": {"SCFA":0.4,"pH_reduction":0.3,"Barrier_support":0.2,"Siderophore":-0.6},
    "Vitamin_B12": {"Vitamin_Biosynthesis":0.7,"Barrier_support":0.2},
    "Folate": {"Vitamin_Biosynthesis":0.6},
    "Calcium": {"SCFA":0.5,"pH_reduction":0.4},
    "Magnesium": {"SCFA":0.4},
    "Zinc": {"Barrier_support":0.4,"Siderophore":-0.5}
}

diet_map = {
    "Dietary_Fiber": {
        "Bifidobacterium": 0.9,
        "Lactobacillus": 0.7,
        "Prevotella": 0.8,
        "Bacteroides": 0.6
    },
    "Resistant_Starch": {
        "Ruminococcus": 0.8,
        "Eubacterium": 0.7,
        "Bifidobacterium": 0.6
    },
    "Fermented_Foods": {
        "Lactobacillus": 0.9,
        "Bifidobacterium": 0.7
    },
    "Red_Meat": {
        "Escherichia": 0.6,
        "Enterobacter": 0.7
    },
    "Polyphenols": {
        "Akkermansia": 0.8,
        "Bifidobacterium": 0.6
    }
}
def simulate_diet(abundance, diet, grams_per_day, days):
    new = abundance.copy()

    # Normalize effect
    intensity = (grams_per_day / 50) * (days / 14)
    intensity = min(intensity, 2.0)  # cap effect

    for sp in new.index:
        genus = sp.split("_")[0]
        if genus in diet_map.get(diet, {}):
            growth = diet_map[diet][genus]
            new[sp] += new[sp] * growth * intensity * 0.1

    return new

# ============================================================
# Nutrient â†’ Microbial Drivers â†’ Diet / Probiotic Recommender
# ONE CELL | FULL LOGIC | COLAB READY
# ============================================================


# ------------------------------------------------------------
# 1. MICROBIAL DRIVER FUNCTION (USES YOUR REAL MODEL)
# ------------------------------------------------------------


def microbial_drivers(nutrient, top_k=3):
    scores = {}

    for bug in traits.index:
        score = 0.0
        for trait, weight in nutrients[nutrient].items():
            if trait in traits.columns and pd.notnull(traits.loc[bug, trait]):
                score += traits.loc[bug, trait] * weight
        scores[bug] = score

    ranked = sorted(scores.items(), key=lambda x: x[1], reverse=True)

    increase = [(b, round(s, 3)) for b, s in ranked[:top_k] if s > 0]
    decrease = [(b, round(s, 3)) for b, s in ranked[-top_k:] if s < 0]

    return increase, decrease

# ------------------------------------------------------------
# 2. FUNCTIONAL KNOWLEDGE BASE
# ------------------------------------------------------------
nutrients = {
    "Iron": {
        "scfa": 0.6,
        "mineral_uptake": 0.7,
        "competition": -0.8
    },
    "Vitamin_B12": {
        "scfa": 0.7,
        "vitamin_synthesis": 0.5,
        "competition": -0.6
    },
    "Folate": {
        "vitamin_synthesis": 1.0,
        "scfa": 0.4
    },
    "Vitamin_D": {
        "barrier_modulation": 0.7,
        "competition": -0.6
    },
    "Calcium": {
        "scfa": 0.5,
        "mineral_uptake": 0.6,
        "barrier_modulation": 0.7
    },
    "Magnesium": {
        "scfa": 0.4,
        "mineral_uptake": 0.6
    },
    "Zinc": {
        "mineral_uptake": 0.8,
        "competition": -0.7
    }
}


functional_groups = {
    "megasphaera": "scfa_producer",
    "ruminococcus": "scfa_producer",
    "faecalibacterium": "butyrate_producer",
    "gemmiger": "butyrate_producer",
    "roseburia": "butyrate_producer",
    "eubacterium": "butyrate_producer",
    "prevotella": "fiber_degrader",
    "blautia": "fiber_degrader",
    "dorea": "fiber_degrader",
    "bacteroides": "protein_fermenter",
    "parasutterella": "bile_acid_modulator",
    "escherichia": "pathobiont",
    "enterobacter": "pathobiont",
    "klebsiella": "pathobiont",
    "desulfovibrio": "pathobiont",
}

# ------------------------------------------------------------
# 3. FUNCTION â†’ DIET RULES (EXTENDED)
# ------------------------------------------------------------
functional_diet_map = {
    "scfa": "Resistant starch + dietary fiber",
    "vitamin_synthesis": "Leafy greens, legumes, fermented foods",
    "mineral_uptake": "Whole grains, nuts, seeds (enhance mineral absorption)",
    "barrier_modulation": "Polyphenols, omega-3s, fermented foods (support gut barrier)",
    "competition": "Reduce fat + increase fiber (limit pathobiont overgrowth)",
}


# ------------------------------------------------------------
# 4. PROBIOTIC POLICY
# ------------------------------------------------------------
probiotic_map = {
    "lactobacillus": "Lactobacillus plantarum",
    "bifidobacterium": "Bifidobacterium longum",
}

# ------------------------------------------------------------
# 5. RECOMMENDATION ENGINE
# ------------------------------------------------------------
def get_genus(taxon):
    return taxon.split("_")[0].lower()

def recommend_intervention(increase, decrease, nutrient):
    diets = set()
    probiotics = set()  # keep placeholder if you want to add later

    # Map nutrient trait weights directly to diet rules
    for trait, weight in nutrients[nutrient].items():
        if trait in functional_diet_map:
            # Positive weight â†’ promote trait
            if weight > 0:
                diets.add(functional_diet_map[trait])
            # Negative weight â†’ suppress trait
            elif weight < 0:
                if trait == "competition":
                    diets.add("Reduce fat + increase fiber (limit pathobiont overgrowth)")
                else:
                    diets.add(f"Reduce {trait} activity")

    return sorted(diets), sorted(probiotics), []

# ------------------------------------------------------------
# 6. USER INTERFACE
# ------------------------------------------------------------
nutrient_dropdown = widgets.Dropdown(
    options=list(nutrients.keys()),
    description="Nutrient to improve:",
    style={"description_width": "initial"},
    layout=widgets.Layout(width="350px")
)

run_button = widgets.Button(
    description="Analyze & Recommend",
    button_style="success"
)

output = widgets.Output()

def run_analysis(_):
    with output:
        clear_output()
        nutrient = nutrient_dropdown.value
        increase, decrease = microbial_drivers(nutrient)
        diets, probiotics, annotated = recommend_intervention(increase, decrease, nutrient)

        print("ðŸ§¬ MICROBIAL DRIVERS")
        print(f"\nTarget nutrient: {nutrient}")

        print("\nIncrease:")
        if increase:
            for b, s in increase:
                print(f"  {b} (+{s})")
        else:
            print("  None")

        print("\nDecrease:")
        if decrease:
            for b, s in decrease:
                print(f"  {b} ({s})")
        else:
            print("  None")

        print("\nðŸ¥— DIET RECOMMENDATION")
        if diets:
            for d in diets:
                print(f"  â€¢ {d}")
        else:
            print("  â€¢ No strong diet signal identified")

        print("\nðŸ§ª PROBIOTIC")
        if probiotics:
            for p in probiotics:
                print(f"  â€¢ {p}")
        else:
            print("  â€¢ Not recommended (key drivers are non-probiotic anaerobes)")

        if len(annotated) < len(increase):
            print("\nâ„¹ï¸ Note:")
            print("  Some driver taxa lack functional annotation; expanding the knowledge base may refine recommendations.")

run_button.on_click(run_analysis)

display(widgets.VBox([nutrient_dropdown, run_button, output]))

"""EXTRA

1. Delta change slider
"""

# ==============================
# Î”-ABUNDANCE PERTURBATION MODEL
# ==============================

import pandas as pd
import numpy as np


# ------------------------------
# Load abundance table
# ------------------------------
df = pd.read_csv("india_species_abundance_clean.tsv", sep="\t", index_col=0)

# Heuristic check: bacterial names usually contain '_'
if not any("_" in c for c in df.columns[:10]):
    print("âš ï¸ Columns do not look like bacteria. Transposing table.")
    df = df.T

# ------------------------------
# Build interaction network (Spearman)
# ------------------------------
corr = df.corr(method="spearman")
interaction_matrix = corr.fillna(0)

# Threshold weak interactions
interaction_matrix[interaction_matrix.abs() < 0.3] = 0

# ------------------------------
# Functional traits (example)
# ------------------------------
traits = pd.DataFrame(index=df.columns)

traits["scfa"] = interaction_matrix.mean(axis=1)
traits["fiber_fermentation"] = df.mean()
traits["pathogenicity"] = -interaction_matrix.min(axis=1)

traits = traits.fillna(0)

# ------------------------------
# Nutrient model (traits â†’ nutrients)
# ------------------------------
nutrients = {
    "Iron": {
        "scfa": 0.6,
        "fiber_fermentation": 0.7,
        "pathogenicity": -0.8
    },
    "Vitamin_B12": {
        "scfa": 0.7,
        "pathogenicity": -0.6
    },
    "Folate": {
        "fiber_fermentation": 0.8,
        "scfa": 0.4
    },
    "Calcium": {
        "scfa": 0.5
    },
    "Zinc": {
        "fiber_fermentation": 0.7,
        "pathogenicity": -0.6
    }
}

# ------------------------------
# Î”-Propagation function
# ------------------------------
def simulate_perturbation(target_bacteria, delta):
    Î”B = pd.Series(0.0, index=df.columns)
    Î”B[target_bacteria] = delta

    # Propagate through interaction network
    Î”B_all = interaction_matrix @ Î”B

    # Trait changes
    Î”Traits = traits.T @ Î”B_all

    # Nutrient changes
    nutrient_effects = {}
    for nutrient, weights in nutrients.items():
        score = sum(Î”Traits[t] * w for t, w in weights.items())
        nutrient_effects[nutrient] = round(score, 4)

    return Î”B_all.sort_values(ascending=False), nutrient_effects

# ------------------------------
# UI
# ------------------------------
bacteria_dd = widgets.Dropdown(
    options=df.columns.tolist(),
    description="Perturb bacterium:",
    layout=widgets.Layout(width="450px")
)

delta_slider = widgets.FloatSlider(
    value=0.05,
    min=-0.2,
    max=0.2,
    step=0.01,
    description="Î” Abundance:",
    readout_format=".2f"
)

run_btn = widgets.Button(description="Simulate", button_style="success")
output = widgets.Output()

def run_simulation(_):
    with output:
        clear_output()
        b = bacteria_dd.value
        d = delta_slider.value

        Î”B_all, nutrient_effects = simulate_perturbation(b, d)

        print(f"ðŸ§¬ Perturbation: {b} (Î” = {d})")

        print("\nðŸ“ˆ Most affected bacteria:")
        for k, v in Î”B_all.head(5).items():
            print(f"  {k}: {v:+.4f}")

        print("\nðŸ§ª Nutrient impact:")
        for n, v in nutrient_effects.items():
            direction = "â†‘" if v > 0 else "â†“" if v < 0 else "-"
            print(f"  {n}: {direction} {v}")

run_btn.on_click(run_simulation)

display(widgets.VBox([bacteria_dd, delta_slider, run_btn, output]))

"""Time dependency"""

# ==============================
# TIME-DYNAMIC MICROBIOME MODEL
# ==============================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ------------------------------
# Parameters
# ------------------------------
TIME_STEPS = 30        # days
growth_rate = 0.05    # intrinsic microbial growth
interaction_strength = 0.1

# ------------------------------
# Initial state
# ------------------------------
B0 = df.mean()               # baseline microbiome (mean across samples)
B0 = B0 / B0.sum()           # normalize

# ------------------------------
# Apply perturbation
# ------------------------------
def apply_perturbation(B, target, delta):
    B = B.copy()
    B[target] = max(B[target] + delta, 0)
    return B / B.sum()

# ------------------------------
# Simulate over time
# ------------------------------
def simulate_timecourse(target_bacteria, delta):
    B = apply_perturbation(B0, target_bacteria, delta)

    bacteria_history = []
    nutrient_history = []

    for t in range(TIME_STEPS):
        # Save bacterial state
        bacteria_history.append(B.copy())

        # Trait dynamics
        Traits = traits.T @ B

        # Nutrient dynamics
        nutrients_t = {}
        for n, weights in nutrients.items():
            val = sum(Traits[k] * w for k, w in weights.items())
            nutrients_t[n] = np.tanh(val)   # nonlinear saturation
        nutrient_history.append(nutrients_t)

        # Microbial growth + interactions
        interaction_effect = interaction_matrix @ B
        B = B + growth_rate * B + interaction_strength * interaction_effect

        # Enforce constraints
        B[B < 0] = 0
        B = B / B.sum()

    return pd.DataFrame(bacteria_history), pd.DataFrame(nutrient_history)

# ------------------------------
# Run simulation (example) # Corrected to use a bacterium from B0.index
# ------------------------------
example_bacteria = B0.index[0]   # choose any bacterium from the species list
delta = 0.1

B_traj, N_traj = simulate_timecourse(example_bacteria, delta)

# ------------------------------
# Plot nutrient dynamics
# ------------------------------
plt.figure(figsize=(10, 5))
for col in N_traj.columns:
    plt.plot(N_traj[col], label=col)

plt.axhline(0, linestyle="--", color="gray")
plt.xlabel("Time (days)")
plt.ylabel("Predicted absorption impact")
plt.title(f"Nutrient dynamics after perturbing {example_bacteria}")
plt.legend()
plt.tight_layout()
plt.show()

# ==========================================================
# FULL DYNAMIC MICROBIOME SIMULATOR (1 CELL, END-TO-END)
# ==========================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


# -----------------------------
# LOAD & SANITY CHECK DATA
# -----------------------------
df = pd.read_csv("india_species_abundance_clean.tsv", sep="\t", index_col=0)

# Auto-fix orientation
if not any("_" in c for c in df.columns[:10]):
    df = df.T

# Normalize
df = df.div(df.sum(axis=1), axis=0)
bacteria = df.columns.tolist()

# -----------------------------
# INTERACTION NETWORK (Spearman)
# -----------------------------
interaction_matrix = df.corr(method="spearman").fillna(0)
interaction_matrix[interaction_matrix.abs() < 0.3] = 0

# -----------------------------
# FUNCTIONAL TRAITS (latent)
# -----------------------------
traits = pd.DataFrame(index=bacteria)
traits["scfa"] = interaction_matrix.mean(axis=1)
traits["fiber_fermentation"] = df.mean()
traits["pathogenicity"] = -interaction_matrix.min(axis=1)
traits = traits.fillna(0)

# -----------------------------
# NUTRIENT MODEL
# -----------------------------
nutrients = {
    "Iron": {"scfa": 0.6, "fiber_fermentation": 0.7, "pathogenicity": -0.8},
    "Vitamin_B12": {"scfa": 0.7, "pathogenicity": -0.6},
    "Folate": {"fiber_fermentation": 0.8, "scfa": 0.4},
    "Calcium": {"scfa": 0.5},
    "Zinc": {"fiber_fermentation": 0.7, "pathogenicity": -0.6}
}

# -----------------------------
# SIMULATION PARAMETERS
# -----------------------------
TIME_STEPS = 30
BOOTSTRAPS = 50
growth_rate = 0.05
interaction_strength = 0.1

B0 = df.mean()
B0 = B0 / B0.sum()

# -----------------------------
# CORE SIMULATION
# -----------------------------
def run_simulation(target, delta):
    nutrient_runs = []

    for _ in range(BOOTSTRAPS):
        # bootstrap interaction noise
        noise = np.random.normal(0, 0.05, interaction_matrix.shape)
        A = interaction_matrix + noise

        B = B0.copy()
        B[target] = max(B[target] + delta, 0)
        B = B / B.sum()

        traj = []

        for _ in range(TIME_STEPS):
            Traits = traits.T @ B

            nutrient_vals = {
                n: np.tanh(sum(Traits[t] * w for t, w in weights.items()))
                for n, weights in nutrients.items()
            }
            traj.append(nutrient_vals)

            B = B + growth_rate * B + interaction_strength * (A @ B)
            B[B < 0] = 0
            B = B / B.sum()

        nutrient_runs.append(pd.DataFrame(traj))

    return nutrient_runs

# -----------------------------
# UI
# -----------------------------
bacteria_dd = widgets.Dropdown(
    options=bacteria,
    description="Perturb bacterium:",
    layout=widgets.Layout(width="500px")
)

delta_slider = widgets.FloatSlider(
    value=0.05, min=-0.2, max=0.2, step=0.01,
    description="Î” abundance:"
)

run_btn = widgets.Button(description="Run Simulation", button_style="success")
output = widgets.Output()

def run_model(_):
    with output:
        clear_output()

        target = bacteria_dd.value
        delta = delta_slider.value

        runs = run_simulation(target, delta)

        # Aggregate
        stacked = np.stack([r.values for r in runs])
        mean = stacked.mean(axis=0)
        std = stacked.std(axis=0)

        print(f"ðŸ§¬ Target bacterium: {target}")
        print(f"Î” abundance: {delta}")
        print(f"Time steps: {TIME_STEPS}, Bootstraps: {BOOTSTRAPS}\n")

        plt.figure(figsize=(10,5))
        for i, nutrient in enumerate(runs[0].columns):
            plt.plot(mean[:,i], label=nutrient)
            plt.fill_between(
                range(TIME_STEPS),
                mean[:,i] - std[:,i],
                mean[:,i] + std[:,i],
                alpha=0.2
            )

        plt.axhline(0, linestyle="--", color="gray")
        plt.xlabel("Time (days)")
        plt.ylabel("Predicted absorption impact")
        plt.title("Dynamic nutrient response with uncertainty")
        plt.legend()
        plt.tight_layout()
        plt.show()

run_btn.on_click(run_model)

display(widgets.VBox([
    bacteria_dd,
    delta_slider,
    run_btn,
    output
]))

# ==========================================================
# FULL DYNAMIC MICROBIOME + DIET + NUTRIENT SIMULATOR (1 CELL)
# ==========================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


# -----------------------------
# LOAD DATA
# -----------------------------
df = pd.read_csv("india_species_abundance_clean.tsv", sep="\t", index_col=0)

# Auto-fix orientation (columns must be bacteria)
if not any("_" in c for c in df.columns[:10]):
    df = df.T

# Normalize to relative abundance
df = df.div(df.sum(axis=1), axis=0)
bacteria = df.columns.tolist()

# -----------------------------
# INTERACTION NETWORK
# -----------------------------
interaction_matrix = df.corr(method="spearman").fillna(0)
interaction_matrix[interaction_matrix.abs() < 0.3] = 0

# -----------------------------
# FUNCTIONAL TRAITS
# -----------------------------
traits = pd.DataFrame(index=bacteria)
traits["scfa"] = interaction_matrix.mean(axis=1)
traits["fiber_fermentation"] = df.mean()
traits["pathogenicity"] = -interaction_matrix.min(axis=1)
traits = traits.fillna(0)

# -----------------------------
# NUTRIENT MODEL (TRAITS â†’ NUTRIENTS)
# -----------------------------
nutrients = {
    "Iron": {"scfa": 0.6, "fiber_fermentation": 0.7, "pathogenicity": -0.8},
    "Vitamin_B12": {"scfa": 0.7, "pathogenicity": -0.6},
    "Folate": {"fiber_fermentation": 0.8, "scfa": 0.4},
    "Calcium": {"scfa": 0.5},
    "Magnesium": {"fiber_fermentation": 0.6},
    "Zinc": {"fiber_fermentation": 0.7, "pathogenicity": -0.6},
}

# -----------------------------
# DIET â†’ TRAIT EFFECTS
# -----------------------------
diet_trait_effects = {
    None: {},
    "Dietary_fiber": {"fiber_fermentation": 0.5, "pathogenicity": -0.3},
    "Resistant_starch": {"scfa": 0.4, "fiber_fermentation": 0.2},
    "Fermented_foods": {"scfa": 0.3, "pathogenicity": -0.2},
    "Low_fat_high_fiber": {"fiber_fermentation": 0.4, "pathogenicity": -0.4},
    "High_protein": {"pathogenicity": 0.3},
}

# -----------------------------
# SIMULATION PARAMETERS
# -----------------------------
TIME_STEPS = 30
BOOTSTRAPS = 40
growth_rate = 0.05
interaction_strength = 0.1
diet_strength = 0.05

B0 = df.mean()
B0 = B0 / B0.sum()

# -----------------------------
# DIET BIAS FUNCTION
# -----------------------------
def apply_diet_bias(B, diet):
    if diet not in diet_trait_effects or diet is None:
        return B

    bias = pd.Series(0.0, index=B.index)
    for trait, w in diet_trait_effects[diet].items():
        bias += traits[trait] * w

    bias[bias < 0] = 0
    if bias.sum() > 0:
        bias = bias / bias.sum()

    return B + diet_strength * bias

# -----------------------------
# CORE SIMULATION
# -----------------------------
def run_simulation(target_bacteria, delta, diet):
    all_runs = []

    for _ in range(BOOTSTRAPS):
        A = interaction_matrix + np.random.normal(0, 0.05, interaction_matrix.shape)

        B = B0.copy()
        B[target_bacteria] = max(B[target_bacteria] + delta, 0)
        B = B / B.sum()

        nutrient_traj = []

        for _ in range(TIME_STEPS):
            Traits = traits.T @ B

            nutrient_vals = {
                n: np.tanh(sum(Traits[t] * w for t, w in weights.items()))
                for n, weights in nutrients.items()
            }
            nutrient_traj.append(nutrient_vals)

            B = B + growth_rate * B + interaction_strength * (A @ B)
            B = apply_diet_bias(B, diet)
            B[B < 0] = 0
            B = B / B.sum()

        all_runs.append(pd.DataFrame(nutrient_traj))

    return all_runs

# -----------------------------
# UI
# -----------------------------
bacteria_dd = widgets.Dropdown(
    options=bacteria,
    description="Perturb bacterium:",
    layout=widgets.Layout(width="500px")
)

delta_slider = widgets.FloatSlider(
    value=0.05, min=-0.2, max=0.2, step=0.01,
    description="Î” abundance:"
)

diet_dd = widgets.Dropdown(
    options=list(diet_trait_effects.keys()),
    description="Diet intervention:",
    layout=widgets.Layout(width="400px")
)

run_btn = widgets.Button(description="Run Simulation", button_style="success")
output = widgets.Output()

def run_model(_):
    with output:
        clear_output()

        target = bacteria_dd.value
        delta = delta_slider.value
        diet = diet_dd.value

        runs = run_simulation(target, delta, diet)

        stacked = np.stack([r.values for r in runs])
        mean = stacked.mean(axis=0)
        std = stacked.std(axis=0)

        print(f"ðŸ§¬ Target bacterium: {target}")
        print(f"Î” abundance: {delta}")
        print(f"Diet: {diet}")
        print(f"Time: {TIME_STEPS} days | Bootstraps: {BOOTSTRAPS}\n")

        plt.figure(figsize=(10,5))
        for i, nutrient in enumerate(runs[0].columns):
            plt.plot(mean[:,i], label=nutrient)
            plt.fill_between(
                range(TIME_STEPS),
                mean[:,i] - std[:,i],
                mean[:,i] + std[:,i],
                alpha=0.2
            )

        plt.axhline(0, linestyle="--", color="gray")
        plt.xlabel("Time (days)")
        plt.ylabel("Predicted absorption impact")
        plt.title("Dynamic nutrient response with diet & microbiome perturbation")
        plt.legend()
        plt.tight_layout()
        plt.show()

run_btn.on_click(run_model)

display(
    widgets.VBox([
        bacteria_dd,
        delta_slider,
        diet_dd,
        run_btn,
        output
    ])
)